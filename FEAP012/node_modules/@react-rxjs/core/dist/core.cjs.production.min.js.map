{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/internal/empty-value.ts", "../src/bind/connectFactoryObservable.ts", "../src/bind/connectObservable.ts", "../src/bind/index.ts", "../src/shareLatest.ts", "../src/stateJsx.tsx", "../src/useStateObservable.ts", "../src/internal/useSyncExternalStoreCjs.ts", "../src/Subscribe.tsx"],
  "sourcesContent": ["export type {\n  AddStopArg,\n  DefaultedStateObservable,\n  EmptyObservableError,\n  NoSubscribersError,\n  PipeState,\n  StateObservable,\n  StatePromise,\n  WithDefaultOperator,\n} from \"@rx-state/core\"\nexport {\n  liftSuspense,\n  sinkSuspense,\n  SUSPENSE,\n  withDefault,\n} from \"@rx-state/core\"\nexport { bind } from \"./bind\"\nexport { shareLatest } from \"./shareLatest\"\nexport { state } from \"./stateJsx\"\nexport { RemoveSubscribe, Subscribe } from \"./Subscribe\"\nexport { useStateObservable } from \"./useStateObservable\"\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { state, StateObservable, SUSPENSE } from \"@rx-state/core\"\nimport { useStateObservable } from \"../\"\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [(...args: A) => Exclude<O, SUSPENSE>, (...args: A) => StateObservable<O>] {\n  const args:\n    | [(...args: A) => Observable<O>]\n    | [(...args: A) => Observable<O>, O | ((...args: A) => O)] =\n    defaultValue === EMPTY_VALUE\n      ? [getObservable]\n      : [getObservable, defaultValue]\n\n  const obs = state(...(args as [(...args: A) => Observable<O>]))\n  return [\n    (...input: A) => useStateObservable(obs(...(input as any))),\n    obs as any,\n  ]\n}\n", "import { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { Observable } from \"rxjs\"\nimport { useStateObservable } from \"../\"\nimport { state } from \"@rx-state/core\"\n\n/**\n * Accepts: An Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @param observable Source observable to be used by the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectObservable<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n) {\n  const sharedObservable$ =\n    defaultValue === EMPTY_VALUE\n      ? state(observable)\n      : state(observable, defaultValue)\n\n  const useStaticObservable = () => useStateObservable(sharedObservable$ as any)\n  return [useStaticObservable, sharedObservable$] as const\n}\n", "import { Observable } from \"rxjs\"\nimport connectFactoryObservable from \"./connectFactoryObservable\"\nimport connectObservable from \"./connectObservable\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport {\n  StateObservable,\n  DefaultedStateObservable,\n  SUSPENSE,\n} from \"@rx-state/core\"\n\n// Adds an additional \"stop\" argument to prevent using factory functions\n// inside high-order-functions directly (e.g. switchMap(factory$))\ntype AddStopArg<A extends Array<any>> = number extends A[\"length\"]\n  ? A\n  : [...args: A, _stop?: undefined]\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n): [() => Exclude<T, typeof SUSPENSE>, StateObservable<T>]\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} defaultValue - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n): [() => Exclude<T, typeof SUSPENSE>, DefaultedStateObservable<T>]\n\n/**\n * Binds a factory observable to React\n *\n * @param {(...args: any) => Observable<T>} getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n): [\n  (...args: AddStopArg<A>) => Exclude<O, typeof SUSPENSE>,\n  (...args: AddStopArg<A>) => StateObservable<O>,\n]\n\n/**\n * Binds a factory observable to React\n *\n * @param {(...args: any) => Observable<T>} getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param {T} defaultValue - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [\n  (...args: AddStopArg<A>) => Exclude<O, typeof SUSPENSE>,\n  (...args: AddStopArg<A>) => DefaultedStateObservable<O>,\n]\n\nexport function bind(observable: any, defaultValue?: any) {\n  return (\n    typeof observable === \"function\"\n      ? (connectFactoryObservable as any)\n      : connectObservable\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n", "import { MonoTypeOperatorFunction, ReplaySubject, share } from \"rxjs\"\n\n/**\n * A RxJS pipeable operator which shares and replays the latest emitted value.\n * It's the equivalent of:\n *\n * ```ts\n * share<T>({\n *   connector: () => new ReplaySubject<T>(1),\n *   resetOnError: true,\n *   resetOnComplete: true,\n *   resetOnRefCountZero: true,\n * })\n * ```\n */\nexport const shareLatest = <T>(): MonoTypeOperatorFunction<T> =>\n  share<T>({\n    connector: () => new ReplaySubject<T>(1),\n    resetOnError: true,\n    resetOnComplete: true,\n    resetOnRefCountZero: true,\n  })\n", "import { state as coreState, StateObservable } from \"@rx-state/core\"\nimport React, { createElement, ReactElement } from \"react\"\nimport { useStateObservable } from \"./useStateObservable\"\n\ndeclare module \"@rx-state/core\" {\n  interface StateObservable<T> extends ReactElement {}\n}\n\nexport const state: typeof coreState = (...args: any[]): any => {\n  const result = (coreState as any)(...args)\n\n  if (typeof result === \"function\") {\n    return (...args: any[]) => enhanceState(result(...args))\n  }\n  return enhanceState(result)\n}\n\nconst cache = new WeakMap<StateObservable<any>, React.ReactNode>()\nfunction enhanceState<T>(state$: StateObservable<T>) {\n  if (!cache.has(state$))\n    cache.set(\n      state$,\n      createElement(() => useStateObservable(state$) as any, {}),\n    )\n\n  const originalPipeState = state$.pipeState.bind(state$)\n  return Object.assign(state$, cache.get(state$)!, {\n    pipeState: (...operators: any[]) =>\n      enhanceState((originalPipeState as any)(...operators)),\n  })\n}\n", "import {\n  DefaultedStateObservable,\n  liftSuspense,\n  NoSubscribersError,\n  StateObservable,\n  StatePromise,\n  SUSPENSE,\n} from \"@rx-state/core\"\nimport { useRef, useState } from \"react\"\nimport useSyncExternalStore from \"./internal/useSyncExternalStore\"\nimport { useSubscription } from \"./Subscribe\"\n\ntype VoidCb = () => void\n\ninterface Ref<T> {\n  source$: StateObservable<T>\n  args: [\n    (cb: VoidCb) => VoidCb,\n    () => Exclude<T, typeof SUSPENSE>,\n    () => Exclude<T, typeof SUSPENSE>,\n  ]\n}\n\nexport const useStateObservable = <O>(\n  source$: StateObservable<O>,\n): Exclude<O, typeof SUSPENSE> => {\n  const subscription = useSubscription()\n  const [, setError] = useState()\n  const callbackRef = useRef<Ref<O>>()\n\n  if (!callbackRef.current) {\n    const getValue = (src: StateObservable<O>) => {\n      const result = src.getValue()\n      if (result instanceof StatePromise)\n        throw result.catch((e) => {\n          if (e instanceof NoSubscribersError) return e\n          throw e\n        })\n      return result as any\n    }\n\n    const gv: <T>() => Exclude<T, typeof SUSPENSE> = () => {\n      const src = callbackRef.current!.source$ as DefaultedStateObservable<O>\n      if (!src.getRefCount() && !src.getDefaultValue) {\n        if (!subscription) throw new Error(\"Missing Subscribe!\")\n        subscription(src)\n      }\n      return getValue(src)\n    }\n\n    callbackRef.current = {\n      source$: null as any,\n      args: [, gv, gv] as any,\n    }\n  }\n\n  const ref = callbackRef.current\n  if (ref.source$ !== source$) {\n    ref.source$ = source$\n    ref.args[0] = (next: () => void) => {\n      const subscription = liftSuspense()(source$).subscribe({\n        next,\n        error: (e) => {\n          setError(() => {\n            throw e\n          })\n        },\n      })\n      return () => {\n        subscription.unsubscribe()\n      }\n    }\n  }\n\n  return useSyncExternalStore(...ref!.args)\n}\n", "export { useSyncExternalStore as default } from \"use-sync-external-store/shim\"\n", "import React, {\n  useState,\n  Suspense,\n  useEffect,\n  ReactNode,\n  useRef,\n  createContext,\n  useContext,\n} from \"react\"\nimport { Observable, Subscription } from \"rxjs\"\nimport { liftSuspense, StateObservable } from \"@rx-state/core\"\nimport { EMPTY_VALUE } from \"./internal/empty-value\"\n\nconst SubscriptionContext = createContext<\n  ((src: StateObservable<any>) => void) | null\n>(null)\nconst { Provider } = SubscriptionContext\nexport const useSubscription = () => useContext(SubscriptionContext)\n\nconst p = Promise.resolve()\nconst Throw = () => {\n  throw p\n}\n\n/**\n * A React Component that:\n * - collects the subscriptions of its children and it unsubscribes them when\n * the component unmounts.\n * - if a source$ property is used, then it ensures that the subscription to the\n * observable will exist before the children gets rendered, and it unsubscribes\n * from it when the component unmounts.\n *\n * If the fallback property is used, then the component will create a Suspense\n * boundary with the provided JSX Element, otherwise it will render null until\n * the subscription exists.\n *\n * @param [source$] (=undefined) - Source observable that the Component will\n * subscrib to before it renders its children.\n * @param [fallback] (=null) - JSX Element to be used by the Suspense boundary.\n *\n * @remarks This Component doesn't trigger any updates from the source$.\n */\nexport const Subscribe: React.FC<{\n  children?: React.ReactNode | undefined\n  source$?: Observable<any>\n  fallback?: NonNullable<ReactNode> | null\n}> = ({ source$, children, fallback }) => {\n  const subscriptionRef = useRef<{\n    s: Subscription\n    u: (source: StateObservable<any>) => void\n  }>()\n\n  if (!subscriptionRef.current) {\n    const s = new Subscription()\n    subscriptionRef.current = {\n      s,\n      u: (src) => {\n        let error = EMPTY_VALUE\n        let synchronous = true\n        s.add(\n          liftSuspense()(src).subscribe({\n            error: (e) => {\n              if (synchronous) {\n                // Can't setState of this component when another one is rendering.\n                error = e\n                return\n              }\n              setSubscribedSource(() => {\n                throw e\n              })\n            },\n          }),\n        )\n        synchronous = false\n        if (error !== EMPTY_VALUE) {\n          throw error\n        }\n      },\n    }\n  }\n\n  const [subscribedSource, setSubscribedSource] = useState<\n    Observable<any> | null | undefined\n  >(null)\n\n  if (subscribedSource !== null && subscribedSource !== source$) {\n    if (source$ === undefined) {\n      setSubscribedSource(source$)\n    } else {\n      try {\n        ;(source$ as any).getValue()\n        setSubscribedSource(source$)\n      } catch (e: any) {}\n    }\n  }\n\n  useEffect(() => {\n    setSubscribedSource(source$)\n    if (!source$) return\n\n    const subscription = liftSuspense()(source$).subscribe({\n      error: (e) =>\n        setSubscribedSource(() => {\n          throw e\n        }),\n    })\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [source$])\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current?.s.unsubscribe()\n      subscriptionRef.current = undefined\n    }\n  }, [])\n\n  const actualChildren =\n    subscribedSource === source$ ? (\n      <Provider value={subscriptionRef.current!.u}>{children}</Provider>\n    ) : fallback === undefined ? null : (\n      <Throw />\n    )\n\n  return fallback === undefined ? (\n    actualChildren\n  ) : subscribedSource === null ? (\n    fallback\n  ) : (\n    <Suspense fallback={fallback}>{actualChildren}</Suspense>\n  )\n}\n\n/**\n * Component that prevents its children from using the parent `Subscribe` boundary\n * to manage their subscriptions.\n */\nexport const RemoveSubscribe: React.FC<{\n  children?: React.ReactNode | undefined\n}> = ({ children }) => <Provider value={null}>{children}</Provider>\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "RemoveSubscribe", "Subscribe", "bind", "shareLatest", "state", "useStateObservable", "__toCommonJS", "import_core", "EMPTY_VALUE", "import_core", "connectFactoryObservable", "getObservable", "defaultValue", "obs", "EMPTY_VALUE", "input", "useStateObservable", "import_core", "connectObservable", "observable", "defaultValue", "sharedObservable$", "EMPTY_VALUE", "useStateObservable", "bind", "observable", "defaultValue", "connectFactoryObservable", "connectObservable", "EMPTY_VALUE", "import_rxjs", "shareLatest", "import_core", "import_react", "import_core", "import_react", "import_shim", "import_react", "import_rxjs", "import_core", "SubscriptionContext", "Provider", "useSubscription", "p", "Throw", "Subscribe", "source$", "children", "fallback", "subscriptionRef", "s", "src", "error", "EMPTY_VALUE", "synchronous", "e", "setSubscribedSource", "subscribedSource", "subscription", "_a", "actualChildren", "React", "RemoveSubscribe", "useStateObservable", "source$", "subscription", "useSubscription", "setError", "callbackRef", "getValue", "src", "result", "e", "gv", "ref", "next", "state", "args", "result", "coreState", "enhanceState", "cache", "state$", "useStateObservable", "originalPipeState", "operators"]
}
